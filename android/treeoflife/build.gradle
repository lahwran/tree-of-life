// vim: set filetype=groovy :

apply plugin: 'android'

android {
    compileSdkVersion 19
    buildToolsVersion "19.1.0"

    defaultConfig {
        minSdkVersion 19
        targetSdkVersion 19
        versionCode 1
        versionName "1.0"
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
    buildTypes {
        release {
            runProguard false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
        }
    }
}

android.applicationVariants.all {
    def ceylonModuleName = "treeoflife.android"
    def ceylonModuleVersion = "1"  // TODO: this should be autodetected :(
    def ceylonExecutable = "/Users/lahwran/ceylonstuff/ceylon-dist/dist/bin/ceylon"
    def ceylonVersion = "1.1.0"

    def pfx = "ceylon-${name}-"
    File ceylonDir = new File(project.buildDir, "ceylon/${name}/").canonicalFile
    File ceylonDirErase = new File(ceylonDir, "erase")

    File ceylonSrc = new File(ceylonDir, "src")
    File ceylonFinalRepo = new File(ceylonDirErase, "finalrepo")
    File ceylonGradleRepo = new File(ceylonDirErase, "gradledepsrepo")
    File ceylonOutRepo = new File(ceylonDir, "outrepo")
    File ceylonDepDir = new File(ceylonDir, "extractedjars")

    def destinationDirectory = javaCompile.destinationDir
    def javaCompileDeps = javaCompile.dependsOn.clone()

    File blobjar = new File(ceylonDir, "blob.jar")

    if (ceylonDirErase.exists()) {
        // WARNING: many java directory-deletion things appear to FOLLOW SYMLINKS!
        // (following symlinks is potentially extremely dangerous)
        // rm does not by default, so I'm using it instead for now
        // but it's not cross platform, needs replacement
        ["rm", "-rf", ceylonDirErase.canonicalPath].execute().waitFor()
    }

    task "${pfx}prepare" {
        dependsOn javaCompileDeps
        doFirst {
            ceylonDir.mkdirs()
            ceylonGradleRepo.mkdirs()
            ceylonOutRepo.mkdirs()
            ceylonSrc.mkdirs()
        }
    }
    task "${pfx}copysource" {
        dependsOn "${pfx}prepare"
        def source = javaCompile.source + fileTree('src/main/java').include('**/*.ceylon')
        inputs.files source
        outputs.dir ceylonSrc
        doFirst {
            source.visit { x ->
                if (x.directory) {
                    return
                }
                File target = new File(ceylonSrc, x.path)
                File parent = target.parentFile
                if (parent != null) {
                    parent.mkdirs()
                }
                target.bytes = x.file.bytes
            }
        }
    }
    task "${pfx}extractdeps" {
        dependsOn "${pfx}prepare"
        def classpath = javaCompile.classpath
        def runtimeJars = plugins.findPlugin(com.android.build.gradle.AppPlugin).runtimeJars
        classpath = files(runtimeJars) + classpath

        inputs.files classpath
        outputs.dir ceylonDepDir.canonicalFile

        doFirst {
            blobjar.delete()
            for (thing in classpath) {
                println("copying ${thing}...")
                copy {
                    from(zipTree(thing))
                    into(ceylonDepDir.canonicalFile)
                }
            }
        }
    }
    task "${pfx}blobjar"(type: Jar) {
        dependsOn "${pfx}extractdeps"
        from fileTree(ceylonDepDir.canonicalFile)
        outputs.upToDateWhen {
            return blobjar.exists()
        }
        archiveName = "blob.jar"
        destinationDir = ceylonDir.canonicalFile
        entryCompression = ZipEntryCompression.STORED
    }
    task "${pfx}importdeps"(type: Exec) {
        dependsOn "${pfx}blobjar"

        commandLine ceylonExecutable, "import-jar",\
                    "--force",\
                    "--out", ceylonGradleRepo.canonicalPath,\
                    "gradleCeylonBuild.gradleDependencies/combinedJar",\
                    blobjar.canonicalPath
    }
    task "${pfx}compile"(type: Exec) {
        dependsOn "${pfx}importdeps"
        dependsOn "${pfx}copysource"
        commandLine ceylonExecutable, \
            "compile",\
            "--out", ceylonOutRepo.canonicalPath,\
            "--rep", ceylonGradleRepo.canonicalPath,\
            "--source", ceylonSrc.canonicalPath,\
            ceylonModuleName
    }
    task "${pfx}appmodule"(type: Exec) {
        dependsOn "${pfx}compile"

        commandLine ceylonExecutable, \
            "copy",\
            "--out", ceylonFinalRepo.canonicalPath,\
            "--rep", ceylonOutRepo.canonicalPath,\
            "--rep", ceylonGradleRepo.canonicalPath,\
            "--jvm",\
            "--recursive",\
            "${ceylonModuleName}/${ceylonModuleVersion}"
    }
    task "${pfx}languagemodule"(type: Exec) {
        dependsOn "${pfx}prepare"

        commandLine ceylonExecutable, \
            "copy",\
            "--out", ceylonFinalRepo.canonicalPath,\
            "--jvm",\
            "ceylon.language/${ceylonVersion}"
    }

    task "${pfx}build" {
        dependsOn "${pfx}languagemodule"
        dependsOn "${pfx}appmodule"
        doLast {
            fileTree(ceylonFinalRepo.canonicalFile).include("**/*.car").include("**/*.jar").visit { x ->
                if (!x.name.endsWith(".car") && !x.name.endsWith(".jar")) {
                    return
                }
                print "copying to output: "
                println x.name
                copy {
                    from(zipTree(x.file.canonicalFile))
                    into(destinationDirectory.canonicalFile)
                }
            }
        }
    }

    javaCompile.dependsOn("${pfx}build")
    javaCompile.enabled = false
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.google.code.gson:gson:2.2.+'
}
